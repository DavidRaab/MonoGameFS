Entity:
Jede Game Entity wird durch eine ID repräsentiert.

Messages:
Alle Messages die im Spiel Aktionen ausführen können

Components:
Sind bestimmte Daten, mit zugehörigen Funktionen um diese zu verändern.
Beispiel für Components: Position, Color, Sprite, Health, ...

Systems:
Enthält eine Tabelle aller state daten für bestimmte Aktion
die pro Frame ausgeführt werden oder eben generell Information
für ein Entity enthält.

Message Generators:
Manche Systeme haben nur die Aufgabe bestimmte Messages zu generieren,
ein Beispiel dafür wäre das "InputSystem". Damit diese sofort im diesem
Frame verarbeitet werden. Laufen zuerst die "Message Generators" dessen
Messages dem "currentMessages" hinzugefügt werden am anfang des updates.
Solche speziellen Systeme müssen/sollten vor allen anderen laufen, und sollten
aber auch limitiert sein. Momentan wäre "UserInput" aus meiner Sicht die einzige
Ausnahme.

Message Bus:
Die Idee ist das es pro Update ein "currentMessages" und ein "nextMessages"
gibt. Jedes System bekommt die "currentMessages" übergeben. Jedes System
behandelt die Message die es behandeln möchte. Zumeist bedeutet das das
eine Message nur einen Eintrag im lokalen State hinzufügt, entfernt
oder verändert (CRUD). Danach läuft jedes System über seine Daten und macht
die entsprechenden Update operation die pro Frame gemacht werden müssen.

Jedes System kann auch wiederrum neue Messages generieren. Diese werden in
"nextMessages" akkumuliert und im nächsten globalen Update() als "currentMessages"
benutzt.

Nach jedem update kann currentMessages verworfen/gecleart werden.



Beispiel:

Das "UserInputSystem" generiert aus seinem eigenen State, das heißt Keyboard,
GamePad, Joystick Input u.s.w. die Message "Jump". 

Ein "CharacterSystem" behandelt die Message "Jump". Diese enthält seinen
eigenen State um z.B. zu Wissen ob der Charackter springen kann oder nicht,
gerade noch im Sprung ist, u.s.w. Bei der Auswertung kann diese Message verworfen
werden. z.B. weil der Character noch im Sprung ist. Oder er sendet eine
Animation wie "AnimationJump (Entity 12) (Direction ...)"

Das AnimationsSystem kann dann für (Entity 12) entsprechend die Jump Animation
animieren lassen.

Wenn es fertig is kann es wiederrum ein "JumpFinished (Entity 12)" Message senden
das dem CharacterSystem mitteilt, das der Character wieder springen kann.

Ebenfalls könnte das "CharacterSystem" neben ein "AnimationJump" noch eine
"PlaySound (soundFile)" als Message senden.

Solch eine Message wird dann vom "SoundSystem" verarbeitet um die entsprechende
Audio File abzuspielen. Das SoundSystem kann sich dann z.B. auch darum kümmern
das eine Audio-File nicht mehrmals pro Frame abgespielt wird, oder ein
grundsätzliches drosseln wie oft eine bestimmte File gleichzeitig abgespielt werden
kann, u.s.w.



Coding:
Die grundsätzliche Idee ist nach dem ECS das jede Entity nur eine ID ist
und sich aus den Daten der verschiedenen Systems zusammensetzt. So könnte eine
Inititalisierung für einen Character z.B. so aussehen.

    let character = Entity.getNew()

    ViewSystem.addSprite (Sprite ....) character
    InputSystem.addGamepad character
    TransformSystem.addPosition (Position ...) character
    HealthSystem.addHealth (Health ...) character

Die ID könnte z.b. ein fortlaufendes int sein. Zur Laufzeit kann jederzeit
für jede ID ein System hinzugefügt oder entfernt werden.

Jegliche weitere veränderungen und bearbeiten läuft danach über die Messages.
